name: PR Auto Review Gate

on:
  pull_request:
    types:
      - ready_for_review
      - synchronize
      - reopened
      - edited

permissions:
  contents: read
  pull-requests: write
  issues: write

concurrency:
  group: pr-auto-review-${{ github.event.pull_request.number }}
  cancel-in-progress: true

jobs:
  product-review-gate:
    if: github.event.pull_request.draft == false
    runs-on: ubuntu-latest
    steps:
      - name: Ensure gh is available
        run: gh --version

      - name: Ensure agent labels exist
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          gh label create android-developer --repo "$REPO" --color 1D76DB --description "Android implementation agent" --force
          gh label create svg-review-agent --repo "$REPO" --color B60205 --description "SVG quality reviewer agent" --force
          gh label create imagen-asset-generator --repo "$REPO" --color 5319E7 --description "Image asset generation agent (Claude + Google Nano Banana)" --force
          gh label create pr-requirements-ux-reviewer --repo "$REPO" --color 5319E7 --description "Product and UX reviewer agent" --force
          gh label create design-coordinator --repo "$REPO" --color FBCA04 --description "Cross-cutting design and UX coordination" --force

      - name: Classify PR and apply labels
        id: classify
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
          PR: ${{ github.event.pull_request.number }}
        run: |
          set -euo pipefail
          files="$(gh pr view "$PR" --repo "$REPO" --json files --jq '.files[].path')"

          has_svg="false"
          has_android="false"
          has_imagen="false"

          while IFS= read -r f; do
            [[ -z "$f" ]] && continue
            case "$f" in
              assets/svg/*|app/src/main/assets/svg/*|assets/manifest.json|app/src/main/assets/assets_manifest.json)
                has_svg="true"
                ;;
              app/src/main/java/*|app/src/main/res/*|app/src/main/AndroidManifest.xml|app/build.gradle*|build.gradle*|settings.gradle*)
                has_android="true"
                ;;
              assets/images/*|app/src/main/assets/images/*|dmv-android/app/src/main/assets/images/*|assets/review/*|app/src/main/assets/review/*|dmv-android/app/src/main/assets/review/*)
                if [[ "$f" == *.png || "$f" == *.jpg || "$f" == *.jpeg || "$f" == *.webp || "$f" == *.avif ]]; then
                  has_imagen="true"
                fi
                ;;
            esac
          done <<< "$files"

          pr_type="other"
          if [[ "$has_svg" == "true" && "$has_android" == "true" ]]; then
            pr_type="mixed"
          elif [[ "$has_svg" == "true" ]]; then
            pr_type="svg"
          elif [[ "$has_android" == "true" ]]; then
            pr_type="android"
          elif [[ "$has_imagen" == "true" ]]; then
            pr_type="image"
          fi

          case "$pr_type" in
            svg)
              gh pr edit "$PR" --repo "$REPO" --add-label imagen-asset-generator --add-label svg-review-agent --add-label design-coordinator
              ;;
            android)
              gh pr edit "$PR" --repo "$REPO" --add-label android-developer --add-label pr-requirements-ux-reviewer --add-label design-coordinator
              ;;
            mixed)
              gh pr edit "$PR" --repo "$REPO" --add-label android-developer --add-label imagen-asset-generator --add-label svg-review-agent --add-label pr-requirements-ux-reviewer --add-label design-coordinator
              ;;
            image)
              gh pr edit "$PR" --repo "$REPO" --add-label imagen-asset-generator --add-label design-coordinator
              ;;
          esac

          if [[ "$has_imagen" == "true" && "$pr_type" != "image" ]]; then
            gh pr edit "$PR" --repo "$REPO" --add-label imagen-asset-generator
          fi

          {
            echo "pr_type=$pr_type"
            echo "has_svg=$has_svg"
            echo "has_android=$has_android"
            echo "has_imagen=$has_imagen"
          } >> "$GITHUB_OUTPUT"

      - name: Product evidence and rubric gate
        env:
          GH_TOKEN: ${{ github.token }}
          REPO: ${{ github.repository }}
          PR: ${{ github.event.pull_request.number }}
          PR_TYPE: ${{ steps.classify.outputs.pr_type }}
          HAS_SVG: ${{ steps.classify.outputs.has_svg }}
          HAS_ANDROID: ${{ steps.classify.outputs.has_android }}
          HAS_IMAGEN: ${{ steps.classify.outputs.has_imagen }}
        run: |
          set -euo pipefail

          marker="<!-- product-review-gate -->"
          body="$(gh pr view "$PR" --repo "$REPO" --json body --jq '.body // ""')"
          comments="$(gh pr view "$PR" --repo "$REPO" --json comments --jq '.comments[].body // ""' 2>/dev/null || true)"
          review_comments="$(gh api "repos/$REPO/pulls/$PR/comments" --jq '.[].body // ""' 2>/dev/null || true)"
          reviews_text="$(gh api "repos/$REPO/pulls/$PR/reviews" --jq '.[].body // ""' 2>/dev/null || true)"
          all_text="$body"$'\n'"$comments"$'\n'"$review_comments"$'\n'"$reviews_text"

          failures=()

          check_checked() {
            local text="$1"
            if ! grep -Fq -- "- [x] $text" <<< "$body" && ! grep -Fq -- "- [X] $text" <<< "$body"; then
              failures+=("Unchecked required checklist item: $text")
            fi
          }

          check_score() {
            local key="$1"
            local score
            score="$(sed -nE "s/.*${key}:[[:space:]]*([1-5])\/5.*/\1/p" <<< "$body" | head -n1)"
            if [[ -z "$score" ]]; then
              failures+=("Missing rubric score: ${key}: N/5")
              return
            fi
            if [[ "$score" -lt 4 ]]; then
              failures+=("${key} score is ${score}/5 (minimum passing score is 4/5)")
            fi
          }

          if ! grep -Fq "## Product Evidence Checklist" <<< "$body"; then
            failures+=("Missing section: ## Product Evidence Checklist")
          fi

          if ! grep -Fq "## Product Rubric (Author Self-Score)" <<< "$body"; then
            failures+=("Missing section: ## Product Rubric (Author Self-Score)")
          fi

          check_checked "Added before/after screenshots for every changed screen or sign."
          check_checked "Added 96dp and 48dp renders for each changed SVG asset (or marked N/A)."
          check_checked "Added at least one in-context app screenshot per changed user flow (or marked N/A)."
          check_checked "Added authoritative reference links for each changed sign/diagram (or marked N/A)."
          check_checked "Verified no P0/P1 visual or UX regressions in this PR."

          check_score "Readability"
          check_score "Semantic Clarity"
          check_score "Contrast"
          check_score "Consistency"

          image_count="$(
            grep -Eoi '!\[[^]]*\]\([^)]+\)|<img[^>]+src=|https://(user-images\.githubusercontent\.com|github\.com/user-attachments/assets)/[^ )]+' <<< "$all_text" | wc -l | tr -d ' ' || true
          )"

          if [[ "$HAS_SVG" == "true" ]] && [[ "${image_count:-0}" -lt 2 ]]; then
            failures+=("SVG changes require at least 2 attached visual artifacts (before/after and 96dp/48dp evidence).")
          fi

          if [[ "$HAS_ANDROID" == "true" ]] && [[ "${image_count:-0}" -lt 1 ]]; then
            failures+=("Android UI changes require at least 1 attached in-context screenshot.")
          fi

          if [[ "$HAS_SVG" == "true" ]]; then
            reference_section="$(awk '
              BEGIN { in_ref = 0 }
              /^## Reference Links/ { in_ref = 1; next }
              /^## / { if (in_ref == 1) in_ref = 0 }
              in_ref == 1 { print }
            ' <<< "$body")"

            if [[ -z "$reference_section" ]]; then
              failures+=("Missing section: ## Reference Links")
            elif ! grep -Eiq 'https?://' <<< "$reference_section"; then
              failures+=("Reference Links section must include at least one authoritative URL.")
            fi
          fi

          verdict_block="$(awk '
            /<!-- product-review-verdict -->/ {
              capture = 1
              block = $0 ORS
              next
            }
            capture == 1 {
              block = block $0 ORS
              if ($0 ~ /<!-- \/product-review-verdict -->/) {
                last = block
                capture = 0
                block = ""
              }
            }
            END { printf "%s", last }
          ' <<< "$all_text")"

          if [[ -z "$verdict_block" ]]; then
            failures+=("Missing structured reviewer verdict comment. Use docs/review/reviewer-agent-prompt.md and include <!-- product-review-verdict --> markers.")
          else
            prompt_version="$(sed -nE 's/^Prompt-Version:[[:space:]]*(.+)$/\1/p' <<< "$verdict_block" | head -n1)"
            reviewer_verdict="$(sed -nE 's/^Verdict:[[:space:]]*(PASS|BLOCK).*$/\1/p' <<< "$verdict_block" | head -n1)"
            reference_compliance="$(sed -nE 's/^Reference Compliance:[[:space:]]*(PASS|FAIL).*$/\1/p' <<< "$verdict_block" | head -n1)"

            if [[ -z "$prompt_version" ]]; then
              failures+=("Reviewer verdict block is missing Prompt-Version.")
            fi

            if [[ -z "$reviewer_verdict" ]]; then
              failures+=("Reviewer verdict block is missing Verdict: PASS|BLOCK.")
            elif [[ "$reviewer_verdict" == "BLOCK" ]]; then
              failures+=("Reviewer verdict is BLOCK.")
            fi

            for sev in P0 P1 P2 P3; do
              if ! grep -Eq "^${sev} Findings:[[:space:]]*" <<< "$verdict_block"; then
                failures+=("Reviewer verdict block is missing '${sev} Findings:' line.")
              fi
            done

            for key in "Readability" "Semantic Clarity" "Contrast" "Consistency"; do
              score_line="$(grep -E "^${key}:[[:space:]]*[1-5]/5" <<< "$verdict_block" | head -n1 || true)"
              score="$(sed -nE 's/.*([1-5])\/5.*/\1/p' <<< "$score_line" | head -n1)"
              if [[ -z "$score" ]]; then
                failures+=("Reviewer verdict block is missing score: ${key}: N/5")
              elif [[ "$score" -lt 4 ]]; then
                failures+=("Reviewer ${key} score is ${score}/5 (minimum passing score is 4/5)")
              fi
            done

            if [[ -z "$reference_compliance" ]]; then
              failures+=("Reviewer verdict block is missing Reference Compliance: PASS|FAIL.")
            elif [[ "$reference_compliance" == "FAIL" ]]; then
              failures+=("Reviewer marked Reference Compliance as FAIL.")
            fi

            if ! grep -Eq '^Reference Links:[[:space:]]*' <<< "$verdict_block"; then
              failures+=("Reviewer verdict block is missing 'Reference Links:' section.")
            fi
          fi

          report=""
          if [[ "${#failures[@]}" -gt 0 ]]; then
            for f in "${failures[@]}"; do
              report+="- ${f}"$'\n'
            done
          fi

          upsert_comment() {
            local state="$1"
            local details="$2"
            local comment_body
            comment_body="$marker
          ## Product Review Gate: ${state}

          **PR type:** \`${PR_TYPE}\`

          ${details}

          Required policies:
          - \`docs/review/product-review-rubric.md\`
          - \`docs/review/reviewer-agent-prompt.md\`"

            existing_id="$(
              gh api "repos/$REPO/issues/$PR/comments" --jq ".[] | select(.user.login==\"github-actions[bot]\") | select(.body | contains(\"$marker\")) | .id" | tail -n1 || true
            )"

            if [[ -n "${existing_id:-}" ]]; then
              gh api --method PATCH "repos/$REPO/issues/comments/$existing_id" -f body="$comment_body" >/dev/null
            else
              gh pr comment "$PR" --repo "$REPO" --body "$comment_body" >/dev/null
            fi
          }

          if [[ "${#failures[@]}" -gt 0 ]]; then
            upsert_comment "FAILED" "$report"
            gh pr review "$PR" --repo "$REPO" --request-changes --body "Product review gate failed.\n\n${report}" || true
            echo "Gate failed."
            exit 1
          fi

          upsert_comment "PASSED" "All required evidence, references, and rubric scores are present."
          echo "Gate passed."
